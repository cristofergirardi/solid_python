import threading
import time
import random

class NumberGenerator:

    _instance = None
    _current_number = 0

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(NumberGenerator, cls).__new__(cls)
        return cls._instance
    
    def getNextNumber(self):
        number = self._current_number
        # Introduce a small random delay
        time.sleep(random.uniform(0.0001, 0.001))
        self._current_number += 1
        return number

# Shared list to store the numbers generated by each thread
results = []

# Lock for thread-safe writing to the results list
results_lock = threading.Lock()

def generate_numbers():
    generator = NumberGenerator()
    for _ in range(1000):
        number = generator.getNextNumber()
        with results_lock:
            results.append(number)

if __name__ == "__main__":
    # Increase the number of threads and iterations to make the test more robust
    threads = []
    for _ in range(100):
        thread = threading.Thread(target=generate_numbers)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    # Check for duplicates and gaps in the sequence
    duplicates = set()
    gaps = []

    # Sort the results to easily check for gaps
    sorted_results = sorted(results)

    # Check for duplicates
    for i in range(1, len(sorted_results)):
        if sorted_results[i] == sorted_results[i - 1]:
            duplicates.add(sorted_results[i])

    # Check for gaps
    for i in range(1, len(sorted_results)):
        if sorted_results[i] != sorted_results[i - 1] + 1:
            gaps.append((sorted_results[i - 1], sorted_results[i]))

    # Output the results
    print(f"Generated numbers: {sorted_results[:50]} ... {sorted_results[-50:]}")  # Show first and last 50 numbers for brevity
    print(f"Duplicates: {duplicates}")
    print(f"Gaps: {gaps}")